#!/usr/bin/env python3

import fitter

import json
import logging
import pathlib
import argparse


default_dir = f"{pathlib.Path.home()}/.GCfit"


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='fit some GCs')

    parser.add_argument('cluster', help='Common name of the cluster to model')

    parser.add_argument('--savedir', default=default_dir,
                        help='location of saved sampling runs')
    parser.add_argument('-i', '--initials',
                        help='alternative JSON file with different intials')
    parser.add_argument('-p', '--priors', dest='param_priors',
                        help='alternative JSON file with different priors')

    parser.add_argument('-N', '--Niters', default=2000, type=int,
                        help='Number of sampling iterations')
    parser.add_argument('--Nwalkers', default=150, type=int,
                        help='Number of walkers for MCMC sampler')

    parser.add_argument('--continue', dest='cont_run', action='store_true',
                        help='Continue from previous saved run')
    parser.add_argument('--backup', action='store_true',
                        help='Create continuous backups during run')

    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--debug', action='store_true')

    parallel_group = parser.add_mutually_exclusive_group()
    parallel_group.add_argument("--Ncpu", default=2, type=int,
                                help="Number of `multiprocessing` processes")
    parallel_group.add_argument("--mpi", action="store_true",
                                help="Run with MPI rather than multiprocessing")

    parser.add_argument('--fix', dest='fixed_params', nargs='*',
                        help='Parameters to fix, not estimate from the MCMC')

    parser.add_argument('--exclude', dest='excluded_likelihoods', nargs='*',
                        help='Likelihood components to exclude from posteriors')

    parser.add_argument('--no-hyperparams', dest='hyperparams',
                        action='store_false',
                        help="Don't use Bayesian hyperparams")

    args = parser.parse_args()

    # ----------------------------------------------------------------------
    # Do any args preprocessing necessary for calling fitter
    # ----------------------------------------------------------------------

    if args.cont_run:
        raise NotImplementedError

    if args.initials:

        if (init_file := pathlib.Path(args.initials)).is_file():

            with open(init_file, 'r') as init_of:
                args.initials = json.load(init_of)

        else:
            parser.error(f"Cannot access '{init_file}': No such file")

    if args.param_priors:

        if (bnd_file := pathlib.Path(args.param_priors)).is_file():

            with open(bnd_file, 'r') as init_of:
                args.param_priors = json.load(init_of)

        else:
            parser.error(f"Cannot access '{bnd_file}': No such file")

    pathlib.Path(args.savedir).mkdir(exist_ok=True)

    if debug := args.debug:
        args.verbose = True

    del args.debug

    # ----------------------------------------------------------------------
    # Setup logging
    # ----------------------------------------------------------------------

    config = {
        'level': logging.DEBUG if debug else logging.INFO,
        'format': ('%(process)s|%(asctime)s|'
                   '%(name)s:%(module)s:%(funcName)s:%(message)s'),
        'datefmt': '%H:%M:%S'
    }

    if args.verbose:
        config['filename'] = f"{args.savedir}/fitter_{args.cluster}.log"
    else:
        config['handlers'] = [logging.NullHandler()]

    logging.basicConfig(**config)

    # ----------------------------------------------------------------------
    # Call fitter
    # ----------------------------------------------------------------------

    print('args:', vars(args))

    fitter.fit(**vars(args))
